# Тест на вакансию Intern Server Core Programmer/ Intern Programmer в Lesta Games
---

- ## Задание №1

  ### Задача:
    > На языке Python или C++ написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.
    > ```python
    > def isEven(value):
    >     return value % 2 == 0
    > ```

  ### Решение:
    Для решения задачи были написаны следующие функции:
  - Реализация №1
    > ```python
    > def isEven(value):
    >     return value & 1 == 0
    > ```
    > Принцип работы этой функции заключается в определении последней цифры в бинарном представлении нашего исходного числа. Ведь, если последняя цифра будет 1, то искомое число не будет четным.
  - Реализация №2
    > ```python
    > def isEven(value):
    >     return (value >> 1) << 1 == value
    > ```
    > Принцип работы этой функции заключается, также как и в прошлой, на факте того, что последняя цифра бинарного представления числа равна нулю. Тогда при побитовом сдвиге сначала вправо, затем влево, наше число будет равно данному. Если же последняя цифра будет равна 1, то про побитовых сдвигах число уменьшиться на 1 и не будет равно данному.
  - Реализация №3
    > ```python
    > def isEven(value):
    >     even_nums = {'0', '2', '4', '6', '8'}
    >     return str(value)[-1] in even_nums
    > ```
    > Принцип работы этой функции заключается в том, что мы берем последнюю цифру нашего числа и проверяем, является ли она четной (ще ее в множестве {0, 2, 4, 6, 8}).

  ### Выводы:
    
    #### Для подведения итогов проведём бенчмарк обеих функций. 
    
    ![](https://github.com/spacefellow/LestaTest/blob/main/code/benchmarks/task1.png)

    
Как видно из диаграмм - все методы имеют свои плюсы и минусы. Функция, принцип работы которой заключается 
в нахождении остатка от числа (Code 1) работает сопоставимо быстро с двумя другими реализациями основанными на
нахождении последней цифры в бинарном представлении числа (Code 2) и побитовом сдвиге (Code 3). Самая медленная
реализация основана на определении четности последней цифры числа (Code 4).

Из диаграмм таже видно, что функции, основанные на бинарных представлениях чисел работают быстрее, так как
в них я использовал побитовые операции, которые оптимизированы на уровне аппаратуры и выполняются быстрее, 
чем операторы деления.

Функция (Code 4) работает медленнее остальных, так как я использовал строковое представление числа, операции 
над которыми требуют больших вычислительных ресурсов.

Однако функции, не использующие побитовые операции более интуитивно понятны.
    
|              | Скорость | Удобство |
|--------------|----------|----------|
| Code 1 (%)   |    0     |     +    |
| Code 2 (&)   |    +     |     -    |
| Code 3 (>>)  |    +     |     -    |
| Code 4 (str) |    -     |     +    |
    
- ## Задание №2
  
  ### Задача: <br>
    > На языке Python или С++ написать минимум по 2 класса реализовывающих циклический буфер FIFO. 
     Объяснить плюсы и минусы каждой реализации.
  
  ### Решение:
    Для решения задачи приведу 2 реализации:
  - Реализация №1
  

>  [**Статический кольцевой буфер**](https://github.com/spacefellow/LestaTest/blob/main/code/task2/static.py)
> 
  >  Принцип реализации основан на статитическом кольцевом буфере.
    Изначально создается список заданной длины и два указателя,
    указывающие на начальный и конечный элементы списка. Процесс 
    добавления и удаления элементов основан на перезаписи элементов
    и обновлении указателей. Обновление указателей происходит засчет
    остатка от деления на размер списка, что замедляет процесс удаления
    и добавления элементов.
  - Реализация №2
>  [**Динамический кольцевой буфер**](https://github.com/spacefellow/LestaTest/blob/main/code/task2/dynamic.py)
> 
> Принцип реализации основан на динамическом кольцевом буфере.
    Инициализируется дек, который поддерживает быстрое добавление и
    удаление элементов из начала и конца дека. Данная реализация плоха тем,
    что необходимо использовать дополнительную библиотеку collections.
### Выводы:
  #### Для подведения итогов проведём бенчмарк обеих функций. 
  
  ![](https://github.com/spacefellow/LestaTest/blob/main/code/benchmarks/task2.png)

Тесты проводились на буфере размером 5*10^5 элементов и 10^6 операций. Результаты
подтверждают факт более медленной работы статического кольцевой буфера.

Однако, если в коде не рекомендуется использовать дополнительные библиотеки, то статический кольцевой буфер,
реализованный мной будет хорошим вариантом реализации, в сравнении с наивной реализацией через
список без использования указателей и удалением элементов за O(n).
- ## Задание №3
  ### Задача:
     > На языке Python или С++ предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.
    ### Решение:
    Для решения задачи были реализованы 4 варианта сортировок: 
  - [**Пирамидальная**](https://github.com/spacefellow/LestaTest/blob/main/code/task3/heapsort.py)
  - [**Слиянием**](https://github.com/spacefellow/LestaTest/blob/main/code/task3/mergesort.py)
  - [**Быстрая (2 указателя)**](https://github.com/spacefellow/LestaTest/blob/main/code/task3/quicksort.py)
  - [**Быстрая (3 указателя)**](https://github.com/spacefellow/LestaTest/blob/main/code/task3/quicksort3.py)
     
   ![](https://github.com/spacefellow/LestaTest/blob/main/code/benchmarks/task3_sparse.png)
   > Большие размерности, случайные значения, малое количество повторяющихся элементов

     
   ![](https://github.com/spacefellow/LestaTest/blob/main/code/benchmarks/task3_dense.png)
   > Большие размерности, случайные значения, большое количество повторяющихся элементов

   
   ![](https://github.com/spacefellow/LestaTest/blob/main/code/benchmarks/task3_sparse_partsort.png)
   > Большие размерности, частично отсортированные значения, малое количество повторяющихся элементов

   
   ![](https://github.com/spacefellow/LestaTest/blob/main/code/benchmarks/task3_dense_partsort.png)
   > Большие размерности, частично отсортированные значения, большое количество повторяющихся элементов


На бенчмарках видно, что быстрая сортировка с 3мя указателями практически в любом тесте лидирует. 
У каждой реализованной мной сортировки есть свои плюсы и минусы. Так например, быстрая сортировка (2 указателя) 
и пирамидальная работают быстро на больших объемах данных, однако при большом количестве повторяющихся элементов, пирамидальная выигрывает.
Чтобы ислючить этот недостаток, я реализовал быструю сортировку через 3 указателя.
Быстрая сортировка (3 указателя) работают быстро на больших объемах данных, однако у сортировки слиянием
константа одного прохода выше, чем у быстрой, из-за чего быстрая сортировка работает быстрее.
Также есть сортировка TimSort, реализованная в языке Python, которая использует сортировку слиянием и сортировку вставками,
что позволяет, в среднем, работать быстрее остальных реализаций.